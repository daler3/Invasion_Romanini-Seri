package provaRmi;

import interfacceRemote.AcceptInterface;
import interfacceRemote.ClientComunicazioneInterfaccia;
import interfacceRemote.ServerComunicazioneInterfaccia;

import java.rmi.*;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject; 
import java.util.ArrayList;





//sarà da cambiare
import server_daler.GiocatoreConnesso;


public class AcceptClass extends UnicastRemoteObject implements AcceptInterface{
	
	public AcceptClass() throws RemoteException {
		super();
		// TODO Auto-generated constructor stub
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private ArrayList<ServerComunicazione> clients = null;
	private ArrayList<String> clientNames = null;
	private Object lock = null;
	private Thread serverThread; 
	
	
	@Override
	public ServerComunicazioneInterfaccia inizioConnessione(ClientComunicazioneInterfaccia client) throws RemoteException {
		ServerComunicazione classePerClient = new ServerComunicazione(client);
		Thread threadPerClient = new Thread(classePerClient);
		threadPerClient.start();
		return classePerClient; 
	}







	
//	//costruttore di default 
//	public AcceptClass() throws RemoteException {
////		clients = new ArrayList<ClassForPlayer>(); 
////		clientNames = new ArrayList<String>(); 
//		lock = new Object();
//	}
//	
//	/**
//	 * Questo è chiamato da MyPlayerClass. Ritorna infatti un'interfaccia con i metodi che il giocatore 
//	 * può utilizzare per giocare la partita (e gli altri per la comunicazione col server)
//	 * 
//	 */
//	@Override
//	public ServerComunicazioneInterfaccia login(ClientComunicazioneInterfaccia client, String nameClient, String password) throws RemoteException{
//		//Istanzio una classe per il giocatore. Questa classe implementa InterfaceForPlayer
//		//nel costruttore di classForPlayer creerò il ThreadPlayer. Solo ClassForPlayer avrà il riferimento al Thread.
//		ServerComunicazione classePerClient = new ServerComunicazione(client, nameClient, password, this);
//		//add e remove devono essere synchronized per motivi di consistenza
////		synchronized (lock) {
////		      clients.add(classePerClient);
////		      clientNames.add(nameClient);
////		}
//		Thread threadPerClient = new Thread(classePerClient); 
//		//System.out.println("Nuovo client connesso");
//		//Faccio partire il Thread
//		threadPerClient.start(); //adesso può iniziare a comunicare
//		return classePerClient; 	
//	}
	
	
	/**
	 * registrazione 
	 */
	

	/**
	@Override
	public InterfaceForPlayer login(MyInterface client2, String name, String password) throws RemoteException{
		ClassForPlayer classePerClient = new ClassForPlayer();
		serverThread = new Thread(classePerClient);
		classePerClient.setThread(serverThread);
		synchronized (lock) {
		      clients.add(classePerClient);
		      clientNames.add(name);
		}
		System.out.println("Nuovo client connesso");
		serverThread.start(); 
		return classePerClient;
	}
	*/
	
	

}
