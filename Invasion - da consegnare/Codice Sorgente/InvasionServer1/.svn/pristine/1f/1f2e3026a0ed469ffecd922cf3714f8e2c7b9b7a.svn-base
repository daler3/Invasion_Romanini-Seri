package server_daler;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;

import classiCondivise.BeanGiocatore;
import classiCondivise.Classifica;
import classiCondivise.StatiUtente;
import mappa.Mappa;

import org.omg.CosNaming.NamingContextPackage.NotFound; //per Eccezione NotFound

import dbManager.*;
import eccezioni.TavoloInesistenteException;


/**
 * Classe che gestisce il lato Server del gioco Invasion
 * Singleton
 */
public class Server {
	
	/**
	 * Istanza del Server. 
	 * Se è null creo una nuova istanza 
	 */
	private static Server INSTANCE = null; 
	
	/**
	 * Riferimento al database Manager, per gestire il database
	 */
	private DbManager dbmInvasion; 
	
	/**
	 * È la connessione al db.
	 */
	private Connection connessioneDb;
	
	/**
	 * Lista di giocatori connessi
	 */
	private ArrayList<GiocatoreConnesso> utentiConnessi; 
	
	/**
	 * Lista di tavoli Aperti
	 */
	private ArrayList <TavoloAperto> tavoli; 
	
	/**
	 * Liste di partite in corso
	 */
	private ArrayList <Partita> partite; 
	
	
	/**
	 * Costruttore privato
	 * Crea una nuova istanza della classe DbManager, per gestire il database
	 */
	private Server() {
		this.utentiConnessi = new ArrayList<GiocatoreConnesso>();
		this.tavoli = new ArrayList<TavoloAperto>();
		this.partite = new ArrayList<Partita>();
		this.dbmInvasion = new DbManager();
		try {
			//this.connessioneDb = this.dbmInvasion.connessioneDb();
			this.connessioneDb = dbmInvasion.connessioneDb();  //dava warning
		} catch (InstantiationException | IllegalAccessException
				| ClassNotFoundException | SQLException e) {
			System.err.println("Impossibile connettersi al Database");
			e.printStackTrace();
		}
	}
	
	/**
	 * Metodo per crea un'istanza della classe Server, se essa ancora non esiste.
	 */
	private synchronized static void createInstance() {
		if(INSTANCE==null)
			INSTANCE = new Server();
	}
	
	
	/**
	 * Metodo per ottenere un riferimento alla classe Server
	 * @return l'unica istanza della classe Server
	 */
	public static Server getInstance(){
		if(INSTANCE == null)
			createInstance();
		return INSTANCE; 
	}
	

	/**
	 * Cerchiamo il nuovo idTavolo
	 * Sync perchè non vogliamo che la lista venga alterata nella ricerca.
	 * @return	L'id del nuovo tavolo.
	 */
	public synchronized Integer ottieniIdNuovoTavolo(){
		Iterator<TavoloAperto> itTavoli = this.tavoli.iterator();
		Integer idNuovoTavolo = 1;
		TavoloAperto tavolo;
		while(itTavoli.hasNext()){
			tavolo = itTavoli.next();
			if(tavolo.getIdTavolo() > idNuovoTavolo){
				idNuovoTavolo = tavolo.getIdTavolo();
			}
		}
		return idNuovoTavolo + 1;
	}
	
	/**
	 * Crea un tavolo su richiesta del client e ritorna l'id del tavolo creato.
	 * Sync per non alterare la lista dei tavoli.
	 * @param creatoreTavolo	Il creatore del tavolo che verrà aggiunto subito.
	 * @return	L'id del nuovo tavolo.
	 */
	public synchronized Integer creaTavolo(GiocatoreConnesso creatoreTavolo){
		TavoloAperto nuovoTavolo = new TavoloAperto(ottieniIdNuovoTavolo(), creatoreTavolo);
		//Crea la lista di tavoli
		this.tavoli.add(nuovoTavolo);
		//Comunichiamo a tutti (tranne noi) il nuovo tavolo creato
		inviaListaTavoli(creatoreTavolo);
		return nuovoTavolo.getIdTavolo(); 
	}
	
	
	/**
	 * Prova ad aggiungere il giocatore alla lista dei giocatori connessi.
	 * Il synchronized server per modificare l'arrayList di giocatori connessi.
	 * @param giocatoreConnesso	Il GiocatoreConnesso creato alla connessione del client al server.
	 * @param username			Lo username inviato per l'identificazione.
	 * @param password			La password inviata per l'identificazione.
	 * @return					L'esito dell'accesso
	 * @throws SQLException		Impossibile effettuare il login.
	 */
	public synchronized boolean aggiungiGiocatoreConnesso(GiocatoreConnesso giocatoreConnesso,String username, String password) throws SQLException {
		if(giocatoreGiaConnesso(username))
			return false;
		boolean loginEffettuato = dbmInvasion.loginUtente(connessioneDb, username, password);
		if(loginEffettuato){
			//Aggiungiamo le informazioni al giocatore appena connesso
			riempiBeanGiocatore(giocatoreConnesso, username);
			//Aggiungiamo il giocatore ai giocatori connessi
			this.utentiConnessi.add(giocatoreConnesso);
		}
		return loginEffettuato;
	}
	
	/**
	 * Proviamo a registrare il giocatore nel DB.
	 * @param username	Nome del giocatore che si vuole registrare.
	 * @param password	Password del giocatore che si vuole registrare.
	 * @return			Esito registrazione.
	 * @throws SQLException	Impossibile registrarsi.
	 */
	public boolean registraNuovoGiocatore(String username, String password) throws SQLException{
		return dbmInvasion.registraUtente(connessioneDb, username, password);
	}
	
	/**
	 * Controlliamo se siamo nella lista dei giocatori connessi.
	 * Syncronized perchè non vogliamo interferenze nella lettura della lista.
	 * @param username	Username del giocatore che stiamo cercando
	 * @return	true: Giocatore già connesso;	false: Giocatore disconnesso;
	 */
	private synchronized boolean giocatoreGiaConnesso(String username){
		Iterator<GiocatoreConnesso> itGiocatori = utentiConnessi.iterator();
		while(itGiocatori.hasNext()){
			GiocatoreConnesso giocatore = itGiocatori.next();
			if(giocatore.getMieInfo().getNomeUtente().equals(username))
					return true;
		}
		return false;
	}
	
	/**
	 * Comunica un cambiamento nella lista dei tavoli a tutti gli utenti.
	 * Synchronized per evitare modifiche alla lista dei giocatori connessi.
	 */
	public synchronized void inviaListaTavoli(){
		Iterator<GiocatoreConnesso> itUtenti =  this.utentiConnessi.iterator();
		GiocatoreConnesso giocatoreTemp; 
		while(itUtenti.hasNext()){
			giocatoreTemp = itUtenti.next();
			giocatoreTemp.comunicaTavoli(this.tavoli);
			//Il messaggio viene inoltrato al client solo se si trova nel LIMBO
		}
	}
	
	/**
	 * Comunica un cambiamento nella lista dei tavoli a tutti gli utenti tranne l'escluso.
	 * Synchronized per evitare modifiche alla lista dei giocatori connessi.
	 * @param giocatoreEscluso	Giocatore non interessato dalla comunicazione.
	 */
	public synchronized void inviaListaTavoli(GiocatoreConnesso giocatoreEscluso){
		Iterator<GiocatoreConnesso> itUtenti =  this.utentiConnessi.iterator();
		GiocatoreConnesso giocatoreTemp; 
		while(itUtenti.hasNext()){
			giocatoreTemp = itUtenti.next();
			if(giocatoreTemp.getUsername().equals(giocatoreEscluso.getUsername())){
				giocatoreTemp.comunicaTavoli(this.tavoli);
			}
			//Il messaggio viene inoltrato al client solo se si trova nel LIMBO
		}
	}
	
	
	/**
	 * Viene chiamato al login o alla registrazione per istanziare le informazioni del giocatore
	 * @param giocatoreConnesso	Giocatore a cui si aggiungono le informazioni.
	 * @param username			Username del giocatore di cui vogliamo le informazioni.
	 * @throws SQLException		Problema al DB.
	 */
	private void riempiBeanGiocatore(GiocatoreConnesso giocatoreConnesso, String username) throws SQLException{
		BeanGiocatore mioBean = dbmInvasion.estraiBean(connessioneDb, username);
		giocatoreConnesso.setMieInfo(mioBean);
	}
	
	
	
	public boolean cambiaPassword(Connection connessioneDb, GiocatoreConnesso giocatoreConnesso, String vecchiaPassword, String nuovaPassword) throws SQLException{
		String username = giocatoreConnesso.getUsername();
		return dbmInvasion.cambiaPassword(connessioneDb, username, vecchiaPassword, nuovaPassword);
	}
	
	public BeanGiocatore ottieniInfoUtente (GiocatoreConnesso giocatore){
		BeanGiocatore infoUtente = giocatore.getMieInfo().clone();   //non so se è il clone
		return infoUtente;
	}
	

	
	public Classifica ottieniClassifica() throws SQLException{
		return dbmInvasion.classificaGenerale(connessioneDb);
	}
	
	
	/**
	 * Metodo per ricavare il riferimento a un oggetto Giocatore, partendo dal suo Username 
	 * @param nomeGiocatore - lo username del giocatore di interesse
	 * @return -Il riferimento al giocatore corrispondente allo username passato come parametro. .-null se non viene trovato il giocatore con quel username
	 */
	public GiocatoreConnesso usernameToPlayer (String nomeGiocatore){
		Iterator<GiocatoreConnesso> iteratoreGiocatori = this.utentiConnessi.iterator();
		GiocatoreConnesso giocatoreTemp;
		while(iteratoreGiocatori.hasNext()){
			giocatoreTemp = iteratoreGiocatori.next();
			if(giocatoreTemp.getUsername() == nomeGiocatore)
				return giocatoreTemp;  
		}
		return null;  //se non lo trova \\TODO manderei un'eccezione
	}
	
	
	public void rimuoviDaConnessi(GiocatoreConnesso giocatoreDaRimuovere){
		this.utentiConnessi.remove(giocatoreDaRimuovere); 
		//TODO Comunicare a tutti
		
	}
	
	
	
	public synchronized boolean joinTavolo(GiocatoreConnesso giocatoreDaAggiungere, Integer idtavolo){
		try {
			TavoloAperto tavoloTemp = idToTavolo(idtavolo);
			boolean aggiuntaRiuscita = tavoloTemp.aggiungiGiocatore(giocatoreDaAggiungere);
			if(aggiuntaRiuscita){
				//TODO Come far avviare il tavolo?
				
			}
			return aggiuntaRiuscita; 
		} catch (TavoloInesistenteException e) {
			//Il tavolo cercato non esiste più
			return false;
		}
	}
	
	/**
	 * Ci da il riferimento del tavolo a partire dal suo id.
	 * Sync perchè non vogliamo interferenza nella ricerca del tavolo.
	 * @param idtavolo	Id del tavolo ricercato.
	 * @return	Il riferimento al tavolo cercato.
	 * @throws TavoloInesistenteException	Tavolo inesistente.
	 */
	private synchronized TavoloAperto idToTavolo (Integer idtavolo) throws TavoloInesistenteException{
		Iterator<TavoloAperto> iteratoreTavoli = this.tavoli.iterator();
		TavoloAperto tavoloTemp;
		while(iteratoreTavoli.hasNext()){
			tavoloTemp = iteratoreTavoli.next();
			if(tavoloTemp.getIdTavolo() == idtavolo)
				return tavoloTemp;  
		}
		throw new TavoloInesistenteException(); //se arriva qui, non c'era il tavolo con quell'Id
	}
	
	/**
	 * Rimuove il giocatore dal tavolo in cui si trova.
	 * @param giocatoreDaRimuovere	Giocatore che deve essere rimosso dal tavolo.
	 */
	public void rimuoviGiocatoreDaTavolo(GiocatoreConnesso giocatoreDaRimuovere){
		Integer idTavolo;
		try {
			idTavolo = inCheTavolo (giocatoreDaRimuovere);
			rimuoviGiocatoreDaTavolo(giocatoreDaRimuovere, idTavolo);
		} catch (TavoloInesistenteException e) {
			//Il giocatore non fa più parte del tavolo.
			e.printStackTrace();
		}
	}
	
	/**
	 * Rimuove il giocatore dal tavolo indicato.
	 * @param giocatoreDaRimuovere	Giocatore da rimuovere.
	 * @param idTavolo				Tavolo selezionato.
	 */
	public void rimuoviGiocatoreDaTavolo(GiocatoreConnesso giocatoreDaRimuovere, Integer idTavolo){
		try{
			TavoloAperto tavolo = idToTavolo(idTavolo);
			//Proviamo a rimuovere il giocatore
			boolean rimozione = tavolo.rimuoviGiocatore(giocatoreDaRimuovere);
			if (rimozione == true){
				if(tavolo.getGiocatoriInTavolo().isEmpty()){
					//Se non ci sono altri tavoli lo rimuoviamo.
					rimuoviTavoloAperto(tavolo); //TODO vedi l'implementazone, ma qui devo comunicarlo a tutti
				}
			}
		} catch(TavoloInesistenteException e){
			//Il giocatore non è più nel tavolo, no problem.
		}
	}

	/**
	 * Ci comunica l'id del tavolo.
	 * @param giocatoreDaRimuovere.
	 * @return	L'id del tavolo.
	 * @throws TavoloInesistenteException	Tavolo non trovato.
	 */
	public Integer inCheTavolo(GiocatoreConnesso giocatoreDaRimuovere) throws TavoloInesistenteException{
		Iterator<TavoloAperto> itTavoli = this.tavoli.iterator();
		TavoloAperto tavoloTemp; 
		while(itTavoli.hasNext()){
			tavoloTemp = itTavoli.next();
			if (tavoloTemp.getGiocatoriInTavolo().contains(giocatoreDaRimuovere))
				return tavoloTemp.getIdTavolo();
		}
		throw new TavoloInesistenteException(); //non era in nessun tavolo
	}
	
	
	/**
	 * Rimuoviamo il tavolo e comunichiamo a tutti gli utenti nel limbo il cambiamento
	 * @param tavolo	Il tavolo da rimuovere.
	 */
	public void rimuoviTavoloAperto(TavoloAperto tavolo){
		this.tavoli.remove(tavolo);
		Iterator<GiocatoreConnesso> itGiocatori = this.utentiConnessi.iterator();
		GiocatoreConnesso giocatore;
		while(itGiocatori.hasNext()){
			giocatore = itGiocatori.next();
			giocatore.comunicaTavoli(this.tavoli);
			//E' il giocatore che verifica se è all'interno del limbo o meno.
		}
	}
	
	
	
	
	//inizializza una partita
	public void inizializzaPartita(){
		//forse mi torna un integer
		//dbmanager.creapartita   (connessione, listaGiocatore)
		
		//devo comunicarlo a tutti
		
	}
	
	public void chiudiPartita(ArrayList<GiocatoreConnesso> classificaPartita){//TODO Passare informazioni al server per il salvataggio di tutto sul db
		//devo comunicarlo, e devo comunicare i bean ai giocatori
	}
	
	/**
	 * Crea la mappa e la invia a chi ne ha fatto richiesta.
	 * @return	La mappa.
	 * @throws SQLException	Impossibile accedere al DB.
	 */
	public Mappa ottieniMappa() throws SQLException{
		Mappa nuovaMappa = new Mappa(dbmInvasion.estraiContinenti(connessioneDb), dbmInvasion.estraiBonus(connessioneDb), dbmInvasion.estraiTerritori(connessioneDb), dbmInvasion.estraiConfini(connessioneDb));
		return nuovaMappa;
	}
	
	
	
	//TODO porccoooo caneeee
	public void chiudiServer (){
		
	}
	

	
	//ci faccio un for
	//Connection connessione
	//Integer id_partita
	//String giocatore + Integer posizione + Integer punteggio
	
	

	
}
