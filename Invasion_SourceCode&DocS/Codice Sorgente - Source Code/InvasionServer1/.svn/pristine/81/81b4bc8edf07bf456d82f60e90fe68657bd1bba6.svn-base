package server_daler;


import java.sql.SQLException;
import java.util.*;

import mappa.*;
import classiCondivise.*;
import eccezioni.NumeroGiocatoriErratoException;
import exceptionCondivise.ElementoNonPresenteException;
import exceptionCondivise.GiocatoreNonTrovatoException;
import exceptionCondivise.InserimentoMancanteException;
import exceptionCondivise.TerritorioNonTrovatoException;
import exceptionCondivise.UnitaInsufficientiException;

/**
 * Classe che rappresenta una partita in corso
 * 
 */
public class Partita implements Runnable{
	
	
	protected final static int puntiPrimoSe6 = 40;
	protected final static int puntiSecondoSe6 = 10;
	protected final static int puntiPrimoSe5 = 32; 
	protected final static int puntiSecondoSe5 = 8;
	protected final static int puntiPrimoSe4 = 24; 
	protected final static int puntiSecondoSe4 = 6;
	protected final static int puntiPrimoSe3 = 16;
	protected final static int puntiSecondoSe3 = 4; 
	
	private final static int tempoDifesa = 4;
	private final static int tempoSceltaColore = 10;
	private final static int tempoPosizionaArmateIniziale = 60;
	private final static int tempoPosizionaArmateInizioTurno = 30;
	private final static int tempoMossa = 30;
	
	
	/**
	 * Id della partita
	 */
	private Integer idPartita; 
	
	/**
	 * Riferimento alla classe Server
	 */
	private Server mioServer = null; 
	
	/**
	 * Riferimento alla mappa della partita
	 */
	private Mappa mappa = null;
	
	/**
	 * Collection con i riferimenti ai giocatori iniziali della partita
	 */
	private ArrayList<GiocatoreConnesso> giocatoriIniziali = new ArrayList<GiocatoreConnesso>();
	
	private ArrayList<GiocatoreConnesso> giocatoriPartita = new ArrayList<GiocatoreConnesso>();
	
	private ArrayList<GiocatoreConnesso> classificaGiocatori = new ArrayList<GiocatoreConnesso>();
	
	private ArrayList<GiocatoreConnesso> giocatoriRitirati = new ArrayList<GiocatoreConnesso>();
	
	private ArrayList<Colori> coloriInOrdine = new ArrayList<Colori>();
	
	/**
	 * Oggetto di supporto per il posizionamento delle armate a inizio turno
	 */
	private PosizionamentoArmate posizioneIniziale;
	
	private GiocatoreConnesso giocatoreTurno = null;
	
	private boolean mossaEseguita;
	
	private Colori coloreScelto = Colori.NEUTRO; 
	
	private boolean faseIniziale = true; 
	
	private Object lock = new Object(); 
	
	/**
	 * Costruttore della classe Partita. 
	 * @param giocatoriPartitaa - Collection con riferimenti ai thread corrispondendi ai giocatori della partita 
	 * @param mioServer - Riferimento alla classe Server
	 * @throws SQLException Impossibile accedere al DB.
	 */
	public Partita(ArrayList<GiocatoreConnesso> giocatoriPartita, Integer idPartita) throws SQLException { 
		//prendo il riferimento al Server
		this.mioServer = Server.getInstance();
		
		//istanzio una nuova Mappa
		this.mappa = mioServer.ottieniMappa(); 
		this.giocatoriPartita = giocatoriPartita;
		this.giocatoriIniziali = giocatoriPartita;
		this.classificaGiocatori = new ArrayList<GiocatoreConnesso>(giocatoriPartita.size());
		
		this.idPartita = idPartita;
	}
	
	/**
	 * Override del metodo run. 
	 * Inizializza la partita e gestisce la successione dei turni.
	 * Si occupa anche di terminare la partita.
	 *
	 */
	//\\TODO: compattare questo metodo con sottometodi, ma solo dopo aver fatto tutto il resto
	@Override
	public void run(){
		try {
			Thread.sleep(1500);
		} catch (InterruptedException e1) {
			System.err.println("Il Thread è stato Interrotto");
			return; 
		} //mi metto in pausa
		//comunico agli utenti la chiusura del tavolo e quindi l'inizializzazione della partita
		
		//comunicaInizioPartita(); //lo faccio prima (in server)
		
		Boolean continuaPartita = true;
		//Inizializzazione della partita
		try {
			inizializzaPartita();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		faseIniziale = false; 
		while(continuaPartita){
			//Ricavo il prossimo giocatore che deve giocare il turno. 
			//Se è la prima iterazione, mi tornerà il primo giocatore della lista.
			System.out.println("appena prima INIZIALIZZAZIONE turno");
			inizializzazioneTurno(); 
			while(this.giocatoreTurno.isTuoTurno()){
				System.out.println("TURNO DI: "+giocatoreTurno.getUsername());
				attendiMossa();
				System.out.println("TURNO DI: "+giocatoreTurno.getUsername()+"Appena dopo l'attendi MOSSA in RUN");
			}
			//Non c'è bisogno di passare, lo fa l'attendi mossa se non facciamo nulla.
			if(controlloFinePartita()){
				continuaPartita = false; 
				try {
					finePartita();
				} catch (SQLException e) {
					// Impossibile salvare la partita nel DB
					e.printStackTrace();
				}
			}
		}
	}
	
	/**
	 * Setta lo stato dei Giocatori (nel server) a partita e gli da il riferimento alla partita in corso.
	 * 
	 */
	private synchronized void settaStatoGiocatori(){
		Iterator<GiocatoreConnesso> itGiocatori = giocatoriPartita.iterator();
		//ArrayList<BeanGiocatore> infoGiocatoriPartita = ottieniListaBean(giocatoriPartita);
		while(itGiocatori.hasNext()){
			itGiocatori.next().setStatoPartita(this); //comunico le info degli utenti di partita a tutti i partecipanti
		}
	}
	
	
	/**
	 * Crea una lista di BeanGiocatore partendo da una lista di GiocatoreConnesso.
	 * @param giocatori - la lista di GiocatoriConnesi
	 * @return la lista di BeanGiocatore che 
	 */
	private synchronized ArrayList<BeanGiocatore> ottieniListaBean(ArrayList<GiocatoreConnesso> giocatori){
		Iterator<GiocatoreConnesso> itGiocatori = giocatori.iterator();
		ArrayList<BeanGiocatore> infoGiocatori = new ArrayList<BeanGiocatore>(giocatori.size());
		while(itGiocatori.hasNext()){
			infoGiocatori.add(itGiocatori.next().getMieInfo().clone()); //gli passo un clone
		}
		return infoGiocatori;
	}
	
	
	private synchronized void inizializzazioneTurno(){
		setGiocatoreTurno(prossimoGiocatoreTurno());
		inizioTurno(this.giocatoreTurno); //imposta solo tuoturno a true
		comunicaTurno(this.giocatoreTurno.getColoreGiocatore(), this.giocatoreTurno.getUsername());
		//rivedi sta cosa
		ritiraArmateInizioTurno(this.giocatoreTurno); //do al giocatore le armate bonus e aspetto che le posizioni
		//nel frattempo si sono posizionate le armate sui territori
		
		//comunico la mappa definitiva dopo i cambiamenti che il giocatore ha fatto
		comunicaMappa();
	}
	
	
	private synchronized GiocatoreConnesso prossimoGiocatoreTurno(){
		GiocatoreConnesso giocatore = null;

		//Classe di supporto, per procedere all'iterazione dei turni dei giocatori.
			GenericSupport<GiocatoreConnesso> supportoIterazioneListaGiocatori = new GenericSupport<GiocatoreConnesso>();	
			boolean continua = true;
			while(continua){
				try {
					giocatore = supportoIterazioneListaGiocatori.prossimo(this.giocatoreTurno, this.giocatoriIniziali);
					this.giocatoreTurno = giocatore;
					if(this.giocatoriRitirati.contains(giocatore)){
						continue;
					} else {
						continua = false;
						break;
					}
				} catch (ElementoNonPresenteException e) {
					//LA PARTITA è TERMINATA..
				}
			}
		
		return giocatore;
}
	
	/**
	 * Metodo che inizializza la partita
	 * Inizia stabilendo l'ordine iniziale di gioco, finendo con il comunicare ai giocatori la mappa definitiva, dopo la scelta dei colori, l'assegnazione dei territori, e il posizionamento di tutte le armate
	 * 
	 */
	private void inizializzaPartita() {
		settaStatoGiocatori(); //setto lo stato dei giocatori a in partita
		stabilisciOrdineIniziale(); //stabilisco l'ordine iniziale
		sceltaColore(); //
		comunicaOrdineColori();
		comunicaMappa(); //comunico come è fatta la mappa al client
		assegnaTerritoriIniziali(); //localmente
		try {
			assegnaArmateIniziali();
		} catch (NumeroGiocatoriErratoException e1) {
			System.err.println("E' stata avviata una partita con un numero troppo elevato di armate");
			return; 
		} //localmente
		try {
			faseInizialePosizionamentoArmate();
		} catch (InterruptedException e1) {
			if(Thread.interrupted()){ //se il thread è interrotto, finisco
				System.err.println("Il thread è stato interrotto");
				return; 
			}
		} //comunico al client i suoi territori e le sue armate, e gli chiedo di posizionarle
		controllaPosizionamento();
		comunicaMappa();
	}
	
	
	/**
	 * Setta il flag turno nel giocatore a true, per indicare che il suo turno comincia.
	 * @param giocatore - giocatore che deve iniziare il turno
	 */
	private synchronized void inizioTurno(GiocatoreConnesso giocatore){
		giocatore.setTuoTurno(true); //setto il turno (ma non glielo comunico)
	}
	
	
	/**
	 * Comunica a tutti i giocatori (tranne colui di cui è il turno) che il turno di un altro giocatore sta per cominciare
	 * @param colore - colore del giocatore il cui turno sta per cominciare
	 * @param username - username del giocatore il cui turno sta per cominciare
	 */
	private synchronized void comunicaTurno(Colori colore, String username){
		Iterator<GiocatoreConnesso> iteratoreGiocatori = this.giocatoriPartita.iterator();
		GiocatoreConnesso giocatoreTemp;
		while(iteratoreGiocatori.hasNext()){
			giocatoreTemp = iteratoreGiocatori.next();
			//se non è il turno di quel giocatore, gli si comunica di chi è il turno che sta per cominciare
			if(!giocatoreTemp.isTuoTurno()){
				giocatoreTemp.comunicaTurno(colore, username);
			}
		}
	}
	
	
	
	private void fineTurno(){
		//String vecchioGiocatore = this.giocatoreTurno.getUsername();
		this.giocatoreTurno.setTuoTurno(false);	//Forse inutile questa info
		//this.giocatoreTurno = prossimoGiocatore(); 
		//String nuovoGiocatore = this.giocatoreTurno.getUsername();
		//comunicaPassaggioTurno(vecchioGiocatore, nuovoGiocatore);
	}
	

	
	
	/**
	 * Ci mettiamo in attesa della mossa del giocatore per un numero predeterminato di secondi prima di passare.
	 */
	private synchronized void attendiMossa(){
		this.mossaEseguita = false;
		comunicaGiocatoreEffettuareMossa();
		try {
			System.out.println("Mi appisolo ATTENDI MOSSA");
			wait(tempoMossa*1000 + 1000);
			System.out.println("Mi risveglio ATTENDI MOSSA dopo il wait");
			if(this.mossaEseguita){ //se la mossa non è stata eseguita, passa il turno successivo
				//Ogni mossa deve avere un doppio notifyAll(), all'inizio e alla fine della mossa! Anche il PASSA!
				wait();
				System.out.println("Mi risveglio ATTENDI MOSSA dopo il SECONO wait - mossaEseguita");
	
			}
			else{
				System.out.println("appena prima di fine turno in attendi");
				fineTurno();
				System.out.println("appena dopo di fine turno in attendi");
			}
			
		} catch (InterruptedException e) {
			return;
		}
	}
	
	
	public synchronized void notificaFineMossa(){
		//Viene chiamato per risvegliare la partita e far ripartire il countdown
		this.mossaEseguita = false; 
		notifyAll();	//risveglia dal secondo wait
		System.out.println("Mi risveglio ATTENDI MOSSA dopo il notify");
	}
	
	
	private void comunicaGiocatoreEffettuareMossa(){
		this.giocatoreTurno.comunicaAttendiMossa(tempoMossa);
	}
	
	
	
	
	public synchronized void comunicaMossaEseguita(){
		this.mossaEseguita = true;
		notifyAll();	
	}
	
	/**
	 * Metodo per stabilire l'ordine dei turni della partita
	 * Mescola random la lista dei giocatori della partita. 
	 * Chiama poi un metodo che comunica a tutti i giocatori l'ordine stabilito, comunicando i nomi dei partecipanti alla partita. 
	 */
	private synchronized void stabilisciOrdineIniziale(){
		//mescolo la lista dei giocatori per stabilire l'ordine iniziale
		Collections.shuffle(this.giocatoriPartita); 
	}
	
	
	/** 
	 * Metodo che crea la lista dei nomi dei giocatori della partita
	 * @return - la lista (ordinata in base all'ordine della lista dei giocatori nella classe) dei nomi dei giocatori della partita
	 */
	private synchronized ArrayList<String> creaListaUsername(ArrayList<GiocatoreConnesso> listaGiocatori){
		ArrayList<String> nomiGiocatori = new ArrayList<String>(listaGiocatori.size());
		Iterator<GiocatoreConnesso> iteratoreGiocatori = listaGiocatori.iterator();
		while(iteratoreGiocatori.hasNext()){
			nomiGiocatori.add(iteratoreGiocatori.next().getUsername());
		}
		return nomiGiocatori;
	}
	
		
	/**
	 * Metodo che si occupa di far scegliere il colore ai vari giocatori. 
	 * Nell'ordine di gioco, comunica a ogni giocatore di scegliere il colore di gioco (con un certo tempo).
	 * Se la scelta non viene fatta entro il tempo, si assegna un colore di default al giocatore
	 * Una volta terminata la scelta, si comunica a tutti i giocatore l'ordine dei colori. 
	 */
	private void sceltaColore(){
		this.coloriInOrdine = new ArrayList<Colori>(this.giocatoriPartita.size());
		Colori coloreTemp = null; 
		GiocatoreConnesso giocatoreTemp; 
		Iterator<GiocatoreConnesso> iteratoreGiocatori = this.giocatoriPartita.iterator();
		ArrayList<Colori> coloriDisponibili = riempiListaColori(); 
		while(iteratoreGiocatori.hasNext()){
			giocatoreTemp=iteratoreGiocatori.next();
			//chiamo il metodo per la scelta del colore nella classe Player
			giocatoreTemp.scegliColore(tempoSceltaColore, coloriDisponibili);
			attendiSceltaColore();
			coloreTemp = this.coloreScelto;
			//se mi ritorna null significa che non ha scelto nulla, quindi glielo assegno io di default
			if(coloreTemp == null || coloreTemp == Colori.NEUTRO){
				coloreTemp = coloriDisponibili.get(0); //scelgo il primo nella lista (l'utente non aveva scelto in tempo)
			}
			coloriDisponibili.remove(coloreTemp);
			this.coloriInOrdine.add(coloreTemp);
			giocatoreTemp.setColoreGiocatore(coloreTemp);
			this.coloreScelto = Colori.NEUTRO;
		}
	}
	
	
	/**
	 * Riempie una lista di colori con tutti i colori disponibili
	 * @return - un ArrayList con tutti i colori disponibili
	 */
	private ArrayList<Colori> riempiListaColori(){
		ArrayList<Colori> listaColori = new ArrayList<Colori>(Arrays.asList(Colori.values()));	//Arrays.asList(enum) -> Ritorna una lista con tutti gli enum
		listaColori.remove(Colori.NEUTRO); //rimuovo il neutro dalla lsta dei colori
		return listaColori;
	}
	
	/**
	 * 
	 */
	private synchronized void attendiSceltaColore(){
		try {
			wait(tempoSceltaColore*1000 + 1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	//chiamto da GiocatoreConnesso
	public synchronized void coloreScelto(Colori colore){
		this.coloreScelto = colore; 
		notifyAll(); 
	}
	
	
	private void comunicaOrdineColori(){
		ArrayList<BeanGiocatore> listaInfoGiocatori = ottieniListaBean(this.giocatoriPartita);
		Iterator<GiocatoreConnesso> iteratoreGiocatori = this.giocatoriPartita.iterator();
		while(iteratoreGiocatori.hasNext()){
			iteratoreGiocatori.next().comunicaOrdinePartita(listaInfoGiocatori, this.coloriInOrdine);
		}
	}
	
	
	/**
	 * Assegna i territori iniziali (senza comunicare nulla ai giocatori).
	 * Mescola una lista di territori e ne assegna, uno per volta, ai giocatori della partita
	 */
	private void assegnaTerritoriIniziali(){
		GiocatoreConnesso giocatoreTemp = null; 
		Territorio territorioTemp;
		ArrayList<Territorio> territori = (mappa.getListaTerritori());
		Iterator<Territorio> iteratoreTerritori = territori.iterator();
		//mescolo la lista di territori
		Collections.shuffle(territori);
		//classe generica dove è implementato il metodo "prossimo", che mi torna il prossimo elemento in un'ArrayList
		//se si è arrivati alla fine della lista, ritorna l'indice del primo elemento.
		//se invece ciò che è preso in ingresso è null, torna il primo elemento della lista.
		GenericSupport<GiocatoreConnesso> giocatoriSupport = new GenericSupport<GiocatoreConnesso>();
		while(iteratoreTerritori.hasNext()){
			try {
				giocatoreTemp=giocatoriSupport.prossimo(giocatoreTemp, this.giocatoriPartita);
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			territorioTemp=iteratoreTerritori.next();
			territorioTemp.setColorePossessore(giocatoreTemp.getColoreGiocatore());
			//aggiungo il territorio ai territori posseduti di quel giocatore
			giocatoreTemp.aggiungiTerritoriPosseduti(territorioTemp);
		}
	}
	

	/**
	 * Metodo che assegna il numero di armate iniziali, in base al numero di giocatori:
	 * - 40 armate se si gioca in 3
	 * - 35 armate se si gioca in 4
	 * - 30 armate se si gioca in 5
	 * - 25 armate se si gioca in 6
	 * @throws Exception 
	 */
	private void assegnaArmateIniziali() throws NumeroGiocatoriErratoException{
		//TODO creare eccezioni personalizzate
		Iterator<GiocatoreConnesso> iteratoreGiocatori = this.giocatoriPartita.iterator();
		GiocatoreConnesso giocatoreTemp;
		int numeroGiocatori = this.giocatoriPartita.size();
		for(int i=0; i<numeroGiocatori; i++){
			giocatoreTemp = iteratoreGiocatori.next();
			switch(numeroGiocatori){
				case 3: giocatoreTemp.setNumeroArmateDaPosizionare(40);
						continue;
				case 4: giocatoreTemp.setNumeroArmateDaPosizionare(35);
						continue;
				case 5: giocatoreTemp.setNumeroArmateDaPosizionare(30);
						continue;
				case 6: giocatoreTemp.setNumeroArmateDaPosizionare(25);
						continue;
				default: throw new NumeroGiocatoriErratoException();
			}
		}
	}
	
//	private void attendiPosizionamentoCompleto(int tempo){
//		while(!this.posizioneIniziale.comandiCompleti() && tempo > 0){
//			try {
//				Thread.sleep(1000);
//			} catch (InterruptedException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
//			tempo--;
//		}
//	}
	
	
	private void faseInizialePosizionamentoArmate() throws InterruptedException{		
		this.posizioneIniziale = new PosizionamentoArmate(this.giocatoriPartita.size()); 
		this.posizioneIniziale.abilitaAggiunta(); 
		comunicaTerritoriEPosizionaArmate(); //mando un messaggio ai giocatori comunicando loro i territori e le armate possedute
		this.posizioneIniziale.attendi(tempoPosizionaArmateIniziale+1); //mo sto in attesa
		System.out.println("E' finito il tempo POSIZ..sono partita");
		//ora ho comunicato, mi devo mettere in attesa
		//attendiPosizionamentoCompleto(tempo);
		this.posizioneIniziale.disabilitaAggiunta();
		estraiSceltaGiocatori();
	}
	
	
	private void estraiSceltaGiocatori(){
		Iterator<GiocatoreConnesso> itGiocatori = this.giocatoriPartita.iterator();
		GiocatoreConnesso giocatoreTemp; 		
		while(itGiocatori.hasNext()){	
			giocatoreTemp = itGiocatori.next();	
			try{
				estraiSceltaGiocatoreSingolo(giocatoreTemp);
			} catch (InserimentoMancanteException | TerritorioNonTrovatoException e){
				continue; 
			}
		}
	}
	
	
	public void estraiSceltaGiocatoreSingolo(GiocatoreConnesso giocatoreTemp) throws InserimentoMancanteException, TerritorioNonTrovatoException{
//		if (this.posizioneIniziale.numeroArmatePosizionate(giocatoreTemp.getUsername()) > giocatoreTemp.getNumeroArmateDaPosizionare()){
//			
//			System.out.println("Spero di no ");
//			return;  //se il numero armate da posizionare è maggiore
//		}	
		String[][] tabellaGiocatore;
		try {
			tabellaGiocatore = this.posizioneIniziale.tabellaPosizionamenti(giocatoreTemp.getUsername());
			for(int i = 0; i < tabellaGiocatore.length; i++){
				String nomeTerritorio = tabellaGiocatore[i][0];
				Integer numeroArmate = Integer.parseInt(tabellaGiocatore[i][1]);
				if(numeroArmate > giocatoreTemp.getNumeroArmateDaPosizionare()){
					numeroArmate = giocatoreTemp.getNumeroArmateDaPosizionare();
				}
				//System.out.println("Giocatore: "+giocatoreTemp.getUsername()+" - "+nomeTerritorio+": "+numeroArmate.toString());
				Territorio territorioTemp = nomeToTerritorio(nomeTerritorio);
				territorioTemp.aggiungiUnita(numeroArmate);
				giocatoreTemp.setNumeroArmateDaPosizionare(giocatoreTemp.getNumeroArmateDaPosizionare()-numeroArmate);
				if(giocatoreTemp.getNumeroArmateDaPosizionare() <= 0){
					break;
				}
				//le ho aggiunte tutte sulla mappa, poi la controllo. 
			}
		} catch (ElementoNonPresenteException e) {
			//Il giocatore non aveva inserito il comando
			return;
		}

	}	
		
	
	//chiamata da giocatore, anche x dopo
	//in wait è la partita, non il giocatore
	//non so se deve essere sync ma penso di no dato che aggiungiposizionamento è gia sync
	public void aggiungiPosizionamento(String comandoPosizionamento){
		this.posizioneIniziale.aggiungiComando (comandoPosizionamento); 
	}
	
	
	
	/**
	 * QUESTO METODO MANDA SOLO IL MESSAGGIO AI CLIENT DI POSIZIONARE LE ARMATE, UNA VOLTA CHE L'HA FATTO CON TUTTI
	 */
	//    
	public void comunicaTerritoriEPosizionaArmate(){
		Iterator<GiocatoreConnesso> iteratoreGiocatori = this.giocatoriPartita.iterator();
		GiocatoreConnesso giocatoreTemp;
		while(iteratoreGiocatori.hasNext()){
			//Estraiamo il giocatore
			giocatoreTemp = iteratoreGiocatori.next();
			//questo metodo cominicherà le armate da posizionare, i territori posseduti, e il tempo che si ha per farlo. 
			//i territori posseduti e il numero di armate sono attributi della classe Giocatore
			giocatoreTemp.comunicaTerritoriPosizionaArmate(this.mappa, tempoPosizionaArmateIniziale);			
		}

	}
	
	
	public void setArmateSuTerritorio(GiocatoreConnesso giocatore, Territorio territorioPos, Integer numeroArmate) throws TerritorioNonTrovatoException{
		if(territorioPos.isEnemy(giocatore.getColoreGiocatore())){
			throw new TerritorioNonTrovatoException(); //non era il tuo territorio
		}
		territorioPos.aggiungiUnita(numeroArmate);
		giocatore.setNumeroArmateDaPosizionare((giocatore.getNumeroArmateDaPosizionare())-numeroArmate);
	}
	
	
	/**
	 * Estrae i territori vuoti (creandone una lista) da una lista di territori
	 * @param listaTerritori - lista di territori 
	 * @return - i territori vuoti, cioè su cui non sono state posizionate armate, contenuti nella listaTerritori, passata come parametro
	 */
	private ArrayList<Territorio> creaListaTerritoriVuoti(ArrayList<Territorio> listaTerritori){
		Iterator<Territorio> itTerritori = listaTerritori.iterator();
		ArrayList<Territorio> territoriVuoti = new ArrayList<Territorio>();
		Territorio territorioTemp;
		while (itTerritori.hasNext()){
			territorioTemp=itTerritori.next();
			if(territorioTemp.getUnitaPresenti().equals(0)){
				territoriVuoti.add(territorioTemp);
			}
		}
		return territoriVuoti;
	}
	
	
	/**
	 * Metodo che regolarizza il posizionamento delle armate sui territori di un giocatore, nel caso in cui non abbia posizionato tutte le armate assegnatogli e abbia lasciato dei territori vuoti
	 * @param giocatore - il giocatore di cui si vuole regolarizzare il posizionamento delle armate
	 * @param territoriVuoti - la lista dei territori vuoti di quel giocatore
	 */
	private void piuArmatePiuTerritoriVuoti(GiocatoreConnesso giocatore, ArrayList<Territorio> territoriVuoti){
		int x = 1; //numero unita da aggiungere a ogni iterazione
		while(!territoriVuoti.isEmpty() && giocatore.getNumeroArmateDaPosizionare()>0){
			territoriVuoti.get(0).aggiungiUnita(x);
			territoriVuoti.remove(0);
			giocatore.setNumeroArmateDaPosizionare(giocatore.getNumeroArmateDaPosizionare()-x);
		}
	}
	
	
	/**
	 * Metodo che regolarizza il posizionamento delle armate sui territori di un giocatore, nel caso in cui non abbia posizionato tutte le armate assegnatogli, ma non abbia lasciato territori vuoti (cioè abbia posizionato almeno un'armata su ogni territorio)
	 * @param giocatore - il giocatore di cui si vuole regolarizzare il posizionamento delle armate
	 */
	private void piuArmateNoTerritoriVuoti(GiocatoreConnesso giocatore){
		int x = 1;
		while(giocatore.getNumeroArmateDaPosizionare()>0){
			int i = (new Random()).nextInt(giocatore.getTerritoriPosseduti().size());
			giocatore.getUnTerritorio(i).aggiungiUnita(x);
			giocatore.setNumeroArmateDaPosizionare(giocatore.getNumeroArmateDaPosizionare()-x); 
		}
	}
	
	/**
	 * Metodo che regolarizza il posizionamento delle armate sui territori di un giocatore, nel caso in cui abbia posizionato tutte le armate assegnatogli, ma non abbia lasciato territori vuoti, cioè non abbia posizionato almeno un'armata su ogni territorio
	 * @param giocatore - il giocatore di cui si vuol regolarizzare il posizionamento delle armate
	 * @param territoriVuoti - la lista dei territori vuoti di quel giocatore
	 * @throws ElementoNonPresenteException 
	 * @throws Exception 
	 */
	private void noArmatePiuTerritoriVuoti(GiocatoreConnesso giocatore, ArrayList<Territorio> territoriVuoti){
		int x = 1; 
		Territorio territorioTemp = null;
		GenericSupport<Territorio> itTerritoriSupport = new GenericSupport<Territorio>();
		while(!territoriVuoti.isEmpty()){
			try {
				territorioTemp = itTerritoriSupport.prossimo (territorioTemp, giocatore.getTerritoriPosseduti());
			} catch (ElementoNonPresenteException e1) {
				continue;
			} //tira un'eccezione la generic. \\TODO GUARDACI!!
			if(territorioTemp.getUnitaPresenti().equals(1) || territorioTemp.getUnitaPresenti().equals(0)) //o è 1 o è vuoto
				continue; //passo alla prossima iterazione
			try{
				territorioTemp.rimuoviUnita(x);
				territoriVuoti.get(0).aggiungiUnita(x);
				territoriVuoti.remove(0);
			} catch(UnitaInsufficientiException e){
				continue;
			}			
			 //tira un'eccezione da territorio. \\TODO GUARDACI!!
//			territoriVuoti.get(0).aggiungiUnita(x);
//			territoriVuoti.remove(0);
		}
	}
	
	
	/**
	 * Controlla che il posizionamento delle armate di un singolo giocatore a inizio partita sia corretto e, nel caso non lo sia, lo regolarizza.
	 * @param giocatoreTemp - il giocatore di cui si vuole controllare il posizionamento delle armate
	 * @param territoriVuoti - lista dei territori vuoti, cioè su cui il giocatore non ha posizionato alcuna armata
	 * @throws ElementoNonPresenteException 
	 * @throws UnitaInsufficientiException 
	 * 
	 */
	private void controlloPosizionamentoSingoloGiocatore(GiocatoreConnesso giocatoreTemp, ArrayList<Territorio> territoriVuoti) {
		if(giocatoreTemp.getNumeroArmateDaPosizionare()>0 && territoriVuoti.size()>0){
			//comincio col posizionare le pedine rimanenti sui territori vuoti
			piuArmatePiuTerritoriVuoti(giocatoreTemp, territoriVuoti);
			
		}
		
		if(giocatoreTemp.getNumeroArmateDaPosizionare()>0 && territoriVuoti.size()==0){
			//posiziono le pedine rimanenti a random sui suoi territori
			piuArmateNoTerritoriVuoti(giocatoreTemp);
		}
		
		if(giocatoreTemp.getNumeroArmateDaPosizionare().equals(0) && territoriVuoti.size()>0){
			//se ci sono territori vuoti ma non pu' armate da posizionare, 
			//prendo un'armata da territorio con più di un'armata, la tolgo da quel territorio e la posiziono su un territorio vuoto
			//rimuovo quindi il territorio su cui ho posizionato l'armata dalla lista dei territori vuoti
			noArmatePiuTerritoriVuoti(giocatoreTemp, territoriVuoti); 
		}
	}
	
	
	/**
	 * Controlla che il posizionamento delle armate di tutti i giocatori a inizio partita sia corretto.
	 * 
	 * 
	 */
	private synchronized void controllaPosizionamento() {
		Iterator<GiocatoreConnesso> itGiocatori = this.giocatoriPartita.iterator();
		GiocatoreConnesso giocatoreTemp;
		while(itGiocatori.hasNext()){
			giocatoreTemp = itGiocatori.next();
			ArrayList<Territorio> territoriVuoti = creaListaTerritoriVuoti(giocatoreTemp.getTerritoriPosseduti());
			System.out.println("Giocatore: "+giocatoreTemp.getUsername()+" -Territori vuoti: "+territoriVuoti.toString());
			//a questo punto ho una lista con i territori vuoti
			controlloPosizionamentoSingoloGiocatore(giocatoreTemp, territoriVuoti);
		}
	}
	
	
	/**
	 * Si occupa di comunicare la mappa a tutti i giocatori. 
	 * Chiama, per ogni giocatore, il metodo di comunicazione della mappa.
	 */
	public synchronized void comunicaMappa(){
		Iterator<GiocatoreConnesso> iteratoreGiocatori = this.giocatoriPartita.iterator();
		while(iteratoreGiocatori.hasNext()){
			iteratoreGiocatori.next().comunicaMappa(this.mappa);
		}
	}
	
	/**
	 * Metodo per controllare se il concorrente corrente deve ritirare il bonus di possesso di tutti i territori dello stesso continente, passato come parametro
	 * @param giocatorePartita - giocatore della partita che inizia il turno
	 * @param continente - il continente da controllare
	 * @return -il valore del bonus corrispondente al continente, se il giocatore possiede tutti i territori del continente; -0 se il giocatore non possiede tutti i territori di quel continente
	 */
	private Integer ritiraBonusContinenteSingolo (GiocatoreConnesso giocatorePartita, Continente continente){
		//controllo se il giocatore passato come parametro possiede tutto il continente
		if(continente.hoBonusContinente(giocatorePartita.getColoreGiocatore())){
			//allora il bonus va ritirato
			return continente.getBonus(); 
		}
		return 0; 
	}
	
	
	/**
	 * Metodo per controllare se il concorrente corrente deve ritirare il bonus di possesso di tutti i territori dello stesso continente
	 * @param giocatorePartita - giocatore della partita che inizia il turno
	 * @return la somma dei bonus derivanti dal possesso di uno o più continenti per intero. Ritorna 0 se il giocatore non possiede tutti i territori di alcun continente 
	 */
	private int ritiraBonusContinenti (GiocatoreConnesso giocatorePartita){
		//lista dei continenti
		ArrayList<Continente> listaContinentiTemp = mappa.getListaContinenti();
		//variabile intera che andrà a contenere l'intero valore del bonus
		int bonus=0; 
		Iterator <Continente> iteratoreContinenti = listaContinentiTemp.iterator();
		while(iteratoreContinenti.hasNext()){
			//sommo l'eventuale bonus derivante dal possesso del continente singolo
			bonus=bonus+ritiraBonusContinenteSingolo(giocatorePartita, iteratoreContinenti.next());
		}
		return bonus; 
	}
	
	/**
	 * Metodo per assegnare il numero di armate a un giocatore a inizio turno, derivante dal numero dei territori posseduti
	 * @param giocatorePartita - giocatore della partita che inizia il turno
	 * @return il numero di armate assegnate a un giocatore derivanti dai territori posseduti:
	 */
	private Integer ritiraArmateTerritoriPosseduti(GiocatoreConnesso giocatorePartita){
		Double numeroTerritori = (double) giocatorePartita.getTerritoriPosseduti().size();
		Double divisore = 3.0;
		//faccio il ceiling
		return (int) Math.ceil(numeroTerritori/divisore);
	}
	
	/**
	 *
	 * Metodo per assegnare il numero di armate a un giocatore a inizio turno
	 * @param giocatorePartita - il giocatore della partita che inizia il turno
	 * @return il numero totale di armate assegnate a un giocatore a inizio turno
	 */
	private void ritiraArmateInizioTurno(GiocatoreConnesso giocatorePartita){
		Integer armateTotali = ritiraArmateTerritoriPosseduti(giocatorePartita) + ritiraBonusContinenti(giocatorePartita);
		giocatorePartita.setNumeroArmateDaPosizionare(armateTotali);
		
		this.posizioneIniziale = new PosizionamentoArmate(1); //solo per un giocatore 
		this.posizioneIniziale.abilitaAggiunta(); 
		giocatorePartita.comunicaArmateInizioTurno(armateTotali, tempoPosizionaArmateInizioTurno); //mando un messaggio al giocatore di posizionare le armate
		try {
			this.posizioneIniziale.attendi(tempoPosizionaArmateInizioTurno+1); //mo sto in attesa
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
		} 
		this.posizioneIniziale.disabilitaAggiunta();
		try {
			try {
				estraiSceltaGiocatoreSingolo(giocatorePartita);
			} catch (TerritorioNonTrovatoException e) {
				System.err.println("Il giocatore probabilmente non aveva la mappa aggiornata");
				giocatorePartita.comunicaMappa(mappa);
			}
		} catch (InserimentoMancanteException e) {
			//ha perso le armate
		}	
		giocatorePartita.setNumeroArmateDaPosizionare(0);
	}
	
	
	/**
	 * Metodo per ricavare il riferimento a un oggetto Giocatore, partendo dal suo colore corrente all'interno della partita
	 * @param coloreGiocatore - il colore del giocatore di interesse
	 * @return -Il riferimento al giocatore corrispondente al colore passato come parametro. -null se non viene trovato il giocatore con quel colore
	 * @throws GiocatoreNonTrovatoException Il giocatore non è stato trovato
	 */
	public synchronized GiocatoreConnesso giocatoreAssociatoAlcolore (Colori coloreGiocatore) throws GiocatoreNonTrovatoException{
		Iterator<GiocatoreConnesso> iteratoreGiocatori = this.giocatoriIniziali.iterator();
		GiocatoreConnesso giocatoreTemp;
		while(iteratoreGiocatori.hasNext()){
			giocatoreTemp = iteratoreGiocatori.next();
			if(giocatoreTemp.getColoreGiocatore() == coloreGiocatore)
				return giocatoreTemp;  
		}
		throw new GiocatoreNonTrovatoException(); 
	}
	
//	/**
//	 * Metodo per ricavare il riferimento a un oggetto Giocatore, partendo dal suo Username 
//	 * @param nomeGiocatore - lo username del giocatore di interesse
//	 * @return -Il riferimento al giocatore corrispondente allo username passato come parametro. .-null se non viene trovato il giocatore con quel username
//	 */
//	public GiocatoreConnesso usernameToPlayer (String nomeGiocatore) throws GiocatoreNonTrovatoException{
//		Iterator<GiocatoreConnesso> iteratoreGiocatori = this.giocatoriIniziali.iterator();
//		GiocatoreConnesso giocatoreTemp;
//		while(iteratoreGiocatori.hasNext()){
//			giocatoreTemp = iteratoreGiocatori.next();
//			if(giocatoreTemp.getUsername() == nomeGiocatore)
//				return giocatoreTemp;  
//		}
//		throw new GiocatoreNonTrovatoException();   
//	}
	
	/**
	 * Metodo per ricavare il riferimento a un oggetto Territorio, partendo dal suo nome
	 * @param nomeTerritorio - il nome del di interesse
	 * @return -Il riferimento al territorio corrispondente al nome passato come parametro. -null se non viene trovato il territorio con quel nome
	 */
	public Territorio nomeToTerritorio (String nomeTerritorio) throws TerritorioNonTrovatoException{
		Iterator<Territorio> iteratoreTerritori = this.mappa.getListaTerritori().iterator();
		Territorio territorioTemp;
		while(iteratoreTerritori.hasNext()){
			territorioTemp = iteratoreTerritori.next();
			if(territorioTemp.getNome().equals(nomeTerritorio))
				return territorioTemp;  
		}
		throw new TerritorioNonTrovatoException();
	}
	
	
	
	
	
	
	
	/**
	 * @param numeroUnitaAttaccanti
	 * @param territorioAttaccato
	 * @param territorioAttaccante
	 * @throws UnitaAttaccoInsufficientiException 
	 * @throws GiocatoreNonTrovatoException 
	 * @throws TerritorioNonTrovatoException 
	 * @throws UnitaDifesaInsufficientiException 
	 */
	//\\TODO modificare le stringhe
	public synchronized void attacco(Integer numeroUnitaAttaccanti, String tDifensore, String tAttaccante, GiocatoreConnesso giocatoreAttaccante) throws UnitaInsufficientiException{
		Territorio territorioAttaccante;
		Territorio territorioDifensore;
		try {
			territorioAttaccante = nomeToTerritorio(tAttaccante);
			territorioDifensore = nomeToTerritorio(tDifensore);
		} catch (TerritorioNonTrovatoException e) {
			System.err.println("Il territorio non è stato trovato");
			return;
		}
		//Inizializziamo
		Integer [] risultati = new Integer[2];
		boolean conquistato = false; 
		Colori coloreGiocatoreDifensore = territorioDifensore.getColorePossessore();
		GiocatoreConnesso giocatoreDifensore;
		try {
			giocatoreDifensore = giocatoreAssociatoAlcolore(coloreGiocatoreDifensore);
		} catch (GiocatoreNonTrovatoException e) {
			System.err.println("Il giocatore difensore non è stato trovato tra quelli iniziali della partita");
			return;
		}
		//Controlli
		
		//Attacchiamo con il massimo di unità disponibili	
		if(territorioAttaccante.maxUnitaAttacco() < numeroUnitaAttaccanti){
				numeroUnitaAttaccanti = territorioAttaccante.maxUnitaAttacco();
		}
		//Se non possiamo attaccare desistiamo
		if(! attaccoConsentito(numeroUnitaAttaccanti, territorioDifensore,territorioAttaccante, giocatoreAttaccante)){
			return;
		}
		
	System.out.println("Attacco con queste armate: "+numeroUnitaAttaccanti.toString());
		//inizio attacco
		comunicaMossaEseguita();
		//Lanciamo i dadi
		ArrayList<Integer> risultatoDadiAttacco = lanciaDadi(numeroUnitaAttaccanti);
		Integer numeroUnitaDifesa = territorioDifensore.maxUnitaDifesa();
		ArrayList<Integer> risultatoDadiDifesa = lanciaDadi(numeroUnitaDifesa);
		//Confrontiamo i risultati
		risultati = confrontaRisultati(risultatoDadiAttacco, risultatoDadiDifesa);
		//Applichiamo il risultato dell'attacco: leviamo le armate perse ambo le parti
		modificaTerritori(risultati, territorioDifensore, territorioAttaccante, numeroUnitaAttaccanti);
		//Controlliamo se abbiamo conquistato
		if(! territorioAttaccante.isEnemy(territorioDifensore)){
			conquistato=true;
			giocatoreDifensore.getTerritoriPosseduti().remove(territorioDifensore);
			giocatoreAttaccante.getTerritoriPosseduti().add(territorioDifensore);
		}else 
			conquistato=false;
		//comunica i risultati a tutti
		comunicaRisultatiAttacco(tempoDifesa, territorioAttaccante, territorioDifensore, risultatoDadiAttacco, risultatoDadiDifesa, risultati, conquistato); 
		//comunico la mappa aggiornata
		comunicaMappa();
		if(haPerso(giocatoreDifensore)){
			giocatoreDifensore.setTuoTurno(false);
			//Comunichiamo la sconfitta solo se non si è ritirato - Il ritiro l'abbiamo già comunicato in precedenza
			if(! giocatoriRitirati.contains(giocatoreDifensore)){
				//Quando un giocatore perde lo mettiamo in cima alla classifica
				this.classificaGiocatori.add(0, giocatoreDifensore);
				//Comunichiamo a tutti la sconfitta del giocatore
				comunicaSconfitta(giocatoreDifensore.getUsername());
				//Rimuoviamo il giocatore dai giocatori della partita
				this.giocatoriPartita.remove(giocatoreDifensore);
			}
		}
		notificaFineMossa();
	} 
	
	private boolean attaccoConsentito(Integer numeroUnitaAttaccanti, Territorio territorioAttaccato, Territorio territorioAttaccante, GiocatoreConnesso giocatoreAttaccante) throws UnitaInsufficientiException{
		//Controllo che sia il tuo turno
		if(! giocatoreAttaccante.isTuoTurno()){
			return false;
		}
		//Controlliamo che il giocatore attaccante possegga il territorio
		if(! giocatoreAttaccante.getTerritoriPosseduti().contains(territorioAttaccante)){
			return false;
		}
		//Non possiamo attaccarci un nostro stato
		if(giocatoreAttaccante.getTerritoriPosseduti().contains(territorioAttaccato)){
			return false;
		}
		//Controlliamo che i due territori siano compatibili per l'attacco
		if(! territorioAttaccante.possoAttaccareDaQui(territorioAttaccato, numeroUnitaAttaccanti)){
			return false;
		}
		if(numeroUnitaAttaccanti > territorioAttaccante.maxUnitaAttacco()){
			numeroUnitaAttaccanti = territorioAttaccante.maxUnitaAttacco();
		}
		return true;
	}
	
	public synchronized void spostaArmate(Integer numeroArmateDaSpostare, String origine, String destinazione, GiocatoreConnesso giocatore) throws TerritorioNonTrovatoException{
		if(!giocatore.isTuoTurno()){
			return;
		}
		Territorio territorioOrigine = nomeToTerritorio(origine);
		Territorio territorioDestinazione = nomeToTerritorio(destinazione);
		//TODO eventuali eccezioni date dal controllo delle info passate
		comunicaMossaEseguita();
		try {
			territorioOrigine.spostaUnita(numeroArmateDaSpostare, territorioDestinazione);
			//fineTurno();
		} catch (Exception e) {
			//comunicaMappa();	//Comunichiamo la nuova mappa
			//TODO Comunicare l'impossibilità di spostare
			try {
				Thread.sleep(200);
			} catch (InterruptedException e1) {
				e1.printStackTrace();
			}
		} finally{
			comunicaMappa();
		}
		if(! this.faseIniziale)
			this.posizioneIniziale.notifica(); 
		fineTurno();
		notificaFineMossa();	//Una volta che abbiamo spostato le armate passiamo il turno.
	}
	
	public synchronized void passaTurno(GiocatoreConnesso giocatore){
		if(!giocatore.isTuoTurno()){
			System.out.println("PASSA TURNO - Non è ancora il tuo turno");
			return;
		}
		comunicaMossaEseguita();
		System.out.println("PASSA TURNO - Ho comunicato la mossa eseguita");
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		if(! this.faseIniziale)
			this.posizioneIniziale.notifica();
		System.out.println("PASSA TURNO - Ho notificato a posizione iniziale");
		//Per evitare di fare troppo presto il secondo notify
		fineTurno();
		System.out.println("PASSA TURNO - Ho settato a fine turno");
		notificaFineMossa();
		System.out.println("PASSA TURNO - Ho notificato fine mossa e ho finito il mio compito");
	}
	
	
	public synchronized void comunicaRisultatiAttacco(Integer tempoDifesa, Territorio territorioAttaccante, Territorio territorioAttaccato, ArrayList<Integer> risultatoDadiAttacco, ArrayList<Integer> risultatoDadiDifesa, Integer [] risultati, boolean conquistato){
		Iterator<GiocatoreConnesso> itGiocatoriPartita = this.giocatoriPartita.iterator();
		while(itGiocatoriPartita.hasNext()){
			itGiocatoriPartita.next().comunicaAttacco(tempoDifesa, territorioAttaccante, territorioAttaccato, risultatoDadiAttacco, risultatoDadiDifesa, risultati, conquistato);
		}
	}
	
	

	
	public void modificaTerritori(Integer [] risultati, Territorio territorioAttaccato, Territorio territorioAttaccante, Integer numeroUnitaAttaccanti){
		//Rimuoviamo le unità perse da attaccante e difensore
		try {
			territorioAttaccato.rimuoviUnita(risultati[0]);
			territorioAttaccante.rimuoviUnita(risultati[1]);
		} catch (UnitaInsufficientiException e) {
			System.err.println("Rimozione di un numero troppo elevato di armate");
		}
		//Se conquistiamo il territorio spostiamo le nostre armate nel territorio conquistato
		if(territorioAttaccato.getUnitaPresenti().intValue() <= 0){
			//Lo facciamo nostro
			territorioAttaccato.setColorePossessore(territorioAttaccante.getColorePossessore());
			//Spostiamo nel territorio appena conquistato le unità sopravvissute all'attacco
			territorioAttaccato.setUnitaPresenti(numeroUnitaAttaccanti-risultati[1]);
			//Rimuoviamo dal territorio attaccante le unità spostate nel nuovo territorio
			try {
				territorioAttaccante.rimuoviUnita(numeroUnitaAttaccanti-risultati[1].intValue());
			} catch (UnitaInsufficientiException e) {
				System.err.println("Rimosse troppe unità dopo la conquista");
			}
		}
	}
	/**
	 * 
	 * @param attacco	ArrayList contente i dadi dell'attacco.
	 * @param difesa	ArrayList contente i dadi dell'attacco.
	 * @return Integer[0] -> unità distrutte alla difesa;	Integer[1] -> unità distrutte all'attacco.
	 */
	private Integer[] confrontaRisultati(ArrayList<Integer> attacco, ArrayList<Integer> difesa){
		//Estraiamo il numero di dadi lanciati e in minDadi mettiamo il minor numero di dadi estratti
		Integer numeroDadiAttacco = attacco.size();
		Integer numeroDadiDifesa = difesa.size();
		Integer minDadi = Math.min(numeroDadiAttacco, numeroDadiDifesa);
		//Ordiniamo le due liste dal numero più piccolo al più grande
		Collections.sort(attacco);
		Collections.sort(difesa);
		//array destinato a contenere i risultati dell'attacco
		//in prima posizione unità sconfitte, in seconda unità perse
		Integer [] risultati = {0, 0}; 
		Integer attaccoTemp;
		Integer difesaTemp;
		for(int i=1; i <=minDadi; i++){
			//Estraiamo dal dado + grande al più piccolo
			attaccoTemp = attacco.get(attacco.size()-i);
			difesaTemp = difesa.get(difesa.size()-i);
			if(attaccoTemp > difesaTemp){
				distruggiArmataDifensore(risultati);
			} else distruggiArmataAttaccante(risultati);
		}
		System.out.println("Dadi attacco: "+attacco.toString());
		System.out.println("Dadi difesa: "+difesa.toString());
		System.out.println("Risultati: "+risultati[0].toString()+" - "+risultati[0].toString());
		return risultati; 
	}
	
	private void distruggiArmataAttaccante(Integer[] risultato){
		risultato[1]++;
	}
	
	private void distruggiArmataDifensore(Integer[] risultato){
		risultato[0]++;
	}
	

	/**
	 * 
	 * @param numeroDadi
	 * @return
	 */
	public ArrayList<Integer> lanciaDadi(Integer numeroDadi){
		ArrayList<Integer> risultatoDadi = new ArrayList<Integer>(numeroDadi);
		for(int i=0; i<numeroDadi; i++){
			Dado dado = new Dado();
			risultatoDadi.add(dado.lanciaDado());
		}
		return risultatoDadi;
	}
	
	
	/**
	 * Metodo per controllare se una partita è finita, ovvero se un giocatore ha conquistato tutti i territori della mappa.
	 * @return -true: se la partita è terminata; -false: altrimenti 
	 */
	public synchronized boolean controlloFinePartita(){
		//Controlliamo se siamo gli ultimi rimasti in partita
		if(this.giocatoriPartita.size() == 1)
			return true;	//Siamo gli ultimi
		//Controlliamo se possediamo tutti i territori
		Iterator<Continente> itContinenti = this.mappa.getListaContinenti().iterator();
		Colori coloreTemp1, coloreTemp2; 
		//il metodo coloreBonusContinente() torna il colore 
		coloreTemp1 = itContinenti.next().coloreBonusContinente();
		//se già un solo continente non è posseduto da un solo giocatore, la partita non è sicuramente terminata
		if(coloreTemp1 == null) 
			return false; 
		while(itContinenti.hasNext()){
			coloreTemp2 = itContinenti.next().coloreBonusContinente();
			//Se i colori di due continenti sono diversi, o se, come prima, un continente non è posseduto da qualcuno, la partita non è sicuramente terminate
			//poichè, per terminare, tutti i continenti devono essere posseduti da un unico giocatore
			if(coloreTemp1 != coloreTemp2 || coloreTemp2 == null){
				return false;
			}
		}
		//tutti i continenti sono dello stesso colore
		return true; 
	}
	
	
	//\\TODO
	public synchronized void finePartita() throws SQLException{
		Server mioServer = Server.getInstance();
		GiocatoreConnesso vincitore;
		if(giocatoriPartita.size() == 1){
			vincitore = giocatoriPartita.get(0);
			//String nomeVincitore = vincitore.getUsername(); 
			this.classificaGiocatori.add(0, vincitore); //ora ho la classifica dei giocatori completa
			//comunico la fine della partita ai giocatore
			comunicaFinePartita();
			mioServer.chiudiPartita(this.classificaGiocatori, this.idPartita);
		}
	}
	
	public boolean haPerso(GiocatoreConnesso giocatore){
		return giocatore.getTerritoriPosseduti().isEmpty();
	}
	
	
	/**
	 * Metodo per comunicare la fine della partita (con i risultati) ai giocatori della partita.
	 * @param nomeVincitore - il nome del vincitore della partita
	 * @param punteggi - lista con i punteggi dei vari giocatori, ordinati secondo l'ordine di gioco
	 */
	private synchronized void comunicaFinePartita(){
		int punteggioPrimo = punteggioPrimo(this.giocatoriIniziali.size());
		int punteggioSecondo = punteggioSecondo(this.giocatoriIniziali.size());
		Iterator<GiocatoreConnesso> itGiocatori = this.giocatoriPartita.iterator();
		while(itGiocatori.hasNext()){
			itGiocatori.next().fineDellaPartita(creaListaUsername(this.classificaGiocatori),  punteggioPrimo, punteggioSecondo); 
		}
	}

	public GiocatoreConnesso getGiocatoreTurno() {
		return giocatoreTurno;
	}

	public void setGiocatoreTurno(GiocatoreConnesso giocatoreTurno) {
		this.giocatoreTurno = giocatoreTurno;
	}
	
//	private void comunicaPassaggioTurno(String vecchioGiocatore, String nuovoGiocatore){
//		Iterator<GiocatoreConnesso> itGiocatore = this.giocatoriPartita.iterator();
//		while(itGiocatore.hasNext()){
//			itGiocatore.next().nuovoTurno(vecchioGiocatore, nuovoGiocatore);
//		}
//	}
	
	private synchronized void comunicaSconfitta(String giocatorePerdente){
		Iterator<GiocatoreConnesso> itGiocatori = giocatoriPartita.iterator();
		while(itGiocatori.hasNext()){
			itGiocatori.next().comunicaSconfitta(giocatorePerdente);
		}
	}
	
	/**
	 * Comunichiamo che un giocatore ha abbandonato la partita.
	 * La comunicazione non interessa il giocatore ritirato (che comunque non è piu tra i giocatoriPartita ma tra quelli ritirati
	 * @param giocatorePerdente	Il giocatore ritirato.
	 */
//	private void comunicaRitirata(String giocatorePerdente){
//		Iterator<GiocatoreConnesso> itGiocatori = this.giocatoriPartita.iterator();
//		while(itGiocatori.hasNext()){
//			GiocatoreConnesso giocatore = itGiocatori.next();
//			if(! giocatore.getUsername().equals(giocatorePerdente)){
//				//Comunichiamo a tutti tranne al giocatore che ha abbandonato.
//				giocatore.comunicaSconfitta(giocatorePerdente);
//			}
//		}
//	}
	
	private synchronized void comunicaRitirata(String giocatoreRitirato){
		Iterator<GiocatoreConnesso> itGiocatori = this.giocatoriPartita.iterator();
		while(itGiocatori.hasNext()){
			itGiocatori.next().comunicaRitirata(giocatoreRitirato);
			
		}
	}
	
	
//	public void utenteDisconnesso(GiocatoreConnesso giocatore){
//		//Se l'utente è disconnesso, lo disconnettiamo anche dalla partita.
//		giocatore.comunicaDisconnessione();	//TODO
//		//lo dico alla fine della partita al db cosa ha fatto questo che si è disconnesso/ritrato
//		disconnettiUtente(giocatore);		
//	}
	
	/**
	 * Rimuove il giocatore su richiesta del client dalla partita
	 * @param giocatore	Giocatore da rimuovere.
	 * @throws SQLException Problema al DB
	 */
	public synchronized void disconnettiUtente(GiocatoreConnesso giocatore) throws SQLException{
		//Lo rimuoviamo dalla partita e lo mettiamo nei ritirati
		this.giocatoriRitirati.add(giocatore);
		this.giocatoriPartita.remove(giocatore);
		if(giocatore.isTuoTurno()){
			this.giocatoreTurno.setTuoTurno(false);
			this.posizioneIniziale.notifica();
			notificaFineMossa();
			fineTurno();
		}
		comunicaRitirata(giocatore.getUsername());
		//this.giocatoriRitirati.add(giocatore);
		//Se non ci sono più utenti connessi chiudiamo la partita.
		if(this.giocatoriPartita.size() == 0){
			Server mioServer = Server.getInstance();
			mioServer.chiudiPartita(this.classificaGiocatori, this.idPartita);
		}
	}

	public ArrayList<GiocatoreConnesso> getGiocatoriPartita() {
		return giocatoriPartita;
	}

	public Integer getIdPartita() {
		return idPartita;
	}
	
//	//review
//	public ArrayList<BeanGiocatore> getInfoPartecipanti(){
//		ArrayList<BeanGiocatore> infoGiocatori = new ArrayList<BeanGiocatore>(this.giocatoriIniziali.size());
//		Iterator<GiocatoreConnesso> itGiocIniz = this.giocatoriIniziali.iterator();
//		while(itGiocIniz.hasNext()){
//			infoGiocatori.add(itGiocIniz.next().getMieInfo().clone()); //gli passo un clone
//		}
//		return infoGiocatori;
//	}
	
	/**
	 * Metodo statico per ottenere il punteggio del primo classificato
	 * @param numeroGiocatoriFinale - il numero di giocatori della partita (che non si sono ritirati)
	 * @return il punteggio del primo classificato
	 */
	public static int punteggioPrimo(int numeroGiocatoriFinale){
		if(numeroGiocatoriFinale == 3)
			return puntiPrimoSe3;
		if(numeroGiocatoriFinale == 4)
			return puntiPrimoSe4;
		if(numeroGiocatoriFinale == 5)
			return puntiPrimoSe5;
		if(numeroGiocatoriFinale == 6)
			return puntiPrimoSe6;
		return 0; //non puo' essere per le regole del gioco
	}
	
	/**
	 * Metodo statico per ottenere il punteggio del secondo classificato
	 * @param numeroGiocatoriFinale - il numero di giocatori della partita (che non si sono ritirati)
	 * @return il punteggio del secondo classificato
	 */
	public static int punteggioSecondo(int numeroGiocatoriFinale){
		if(numeroGiocatoriFinale == 3)
			return puntiSecondoSe3;
		if(numeroGiocatoriFinale == 4)
			return puntiSecondoSe4;
		if(numeroGiocatoriFinale == 5)
			return puntiSecondoSe5;
		if(numeroGiocatoriFinale == 6)
			return puntiSecondoSe6;
		return 0; //non puo' essere per le regole del gioco
	}
	
	
	
	//\\TODO: se un client abbandona la partita in modo brusco o premendo "esci"
	//\\TODO: quando finisce una partita, che ci facciamo con sto thread-partita?
	//\\TODO: cosa fare se tutti i giocatori si disconnettono prima della fine della partita
	//\\TODO: rivedere public, private, protected
	
}
	
